# 調査結果: Good Question サービス化に必要な機能とタスク

## 調査の目的

- **Why**: 現在のローカル動作アプリを、複数ユーザーが利用できる SaaS サービスとして公開したい
- **What**: サービス化に必要な技術スタック、実装タスク、および実装順序を明確にする
- **調査日**: 2025-12-26

---

## 調査結果サマリー

サービス化には以下の主要コンポーネントが必要です：
1. **Supabase バックエンド**: ユーザー認証、データベース、Row Level Security (RLS)
2. **ランディングページ**: サービス紹介、ユーザー登録導線
3. **利用制限機能**: 一日一回の無料利用制限（Supabase + クライアント側チェック）
4. **Stripe 課金**: サブスクリプション管理、使用量制限解除
5. **UI 改善**: トレーニング開始ボタンの配置調整

---

## 主要な発見（重要度順）

### 1. Supabase + Next.js の認証フローは Cookie ベースが標準

- **概要**: 2024-2025 年の最新プラクティスでは、`@supabase/ssr` を使用した Cookie ベースの認証が推奨されている
- **根拠**: Server Components、Server Actions、Middleware で統一的にセッション管理が可能
- **実装への影響**: 
  - `createBrowserClient` (クライアント) と `createServerClient` (サーバー) の使い分けが必要
  - Middleware でセッション更新とルート保護を実装
  - `getUser()` でサーバー側の認証検証（`getSession()` は非推奨）

### 2. Stripe の利用制限は「使用量ベース課金」または「クレジットシステム」で実装

- **概要**: 一日一回制限は、Supabase DB で使用履歴を記録し、Stripe の Metering API または独自クレジットシステムで管理
- **根拠**: Stripe API のレート制限（25 req/sec）を考慮し、ローカル DB にデータを保存してWebhook で同期する設計が推奨
- **実装への影響**:
  - Supabase DB に `usage_logs` テーブルを作成
  - 日次リセットのロジックをサーバー側で実装
  - Stripe Webhook でサブスクリプション状態を同期

### 3. ランディングページは認証前のパブリックルートとして実装

- **概要**: Next.js の App Router で `/` をランディングページ、`/app` を認証後のアプリとして分離
- **根拠**: NextAuth.js (Auth.js) や Clerk などの認証ライブラリは、この構成をサポート
- **実装への影響**:
  - ルート構成: `/` (LP), `/auth/signin`, `/auth/signup`, `/app/*` (保護ルート)
  - Middleware で `/app/*` を保護

---

## 詳細情報

### Supabase 認証の詳細

- **情報源**: 
  - [Supabase Auth with Next.js (公式)](https://supabase.com/docs/guides/auth/server-side/nextjs)
  - [2024 年の最新チュートリアル](https://dev.to/...)
- **詳細内容**:
  - **セットアップ手順**:
    1. Supabase プロジェクト作成、API キー取得
    2. `npm install @supabase/supabase-js @supabase/ssr`
    3. `.env.local` に `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY` を設定
    4. クライアント/サーバー用のヘルパー関数作成
  - **認証プロバイダー**: Email/Password, Magic Link, OAuth (Google, GitHub など)
  - **RLS (Row Level Security)**: ユーザーごとのデータアクセス制御をデータベースレベルで実装

### Stripe 課金の詳細

- **情報源**:
  - [Stripe Subscriptions API](https://stripe.com/docs/billing/subscriptions)
  - [Next.js + Stripe 統合ガイド](https://pedroalonso.net/...)
- **詳細内容**:
  - **サブスクリプションプラン**:
    - Free: 一日一回まで
    - Pro: 無制限（月額課金）
  - **実装パターン**:
    - Stripe Checkout でサブスクリプション作成
    - Webhook で `customer.subscription.created`, `customer.subscription.deleted` をハンドリング
    - Supabase DB の `users` テーブルに `subscription_status` カラムを追加
  - **使用量追跡**:
    - `usage_logs` テーブルに `user_id`, `session_id`, `created_at` を記録
    - 日次リセットは UTC 0:00 基準で実装

### ランディングページの詳細

- **情報源**:
  - [Next.js Authentication Best Practices](https://nextjs.org/docs/app/building-your-application/authentication)
  - [Clerk + Next.js](https://clerk.com/docs/quickstarts/nextjs)
- **詳細内容**:
  - **推奨ライブラリ**:
    - NextAuth.js (Auth.js): 柔軟性が高く、多数のプロバイダーをサポート
    - Clerk: UI コンポーネント付きで実装が簡単
    - Supabase Auth: バックエンドと統合されている
  - **ルート構成例**:
    ```
    /                    → ランディングページ（パブリック）
    /auth/signin         → サインイン（パブリック）
    /auth/signup         → サインアップ（パブリック）
    /app                 → ダッシュボード（保護）
    /app/training        → トレーニング画面（保護）
    /app/performance     → パフォーマンス画面（保護）
    ```

---

## 技術選択肢の比較

### 認証ライブラリの選択

#### 選択肢 A: Supabase Auth（推奨）

- **メリット**:
  - バックエンド（DB、認証）が統合されている
  - RLS でデータアクセス制御が簡単
  - 追加ライブラリ不要
- **デメリット**:
  - Supabase に依存
  - カスタマイズ性は NextAuth.js より低い
- **適用場面**: Supabase をバックエンドとして使う場合
- **実装難易度**: 中
- **課題解決への適合度**: 高（DB と認証が統合されているため、利用制限の実装が容易）

#### 選択肢 B: NextAuth.js (Auth.js)

- **メリット**:
  - 多数のプロバイダーをサポート
  - 柔軟性が高い
  - オープンソース
- **デメリット**:
  - Supabase との統合に追加設定が必要
  - セッション管理を自前で実装
- **適用場面**: 複数の認証プロバイダーを柔軟に使いたい場合
- **実装難易度**: 中〜高
- **課題解決への適合度**: 中

#### 選択肢 C: Clerk

- **メリット**:
  - UI コンポーネント付き
  - 実装が非常に簡単
  - ユーザー管理機能が充実
- **デメリット**:
  - 有料（無料枠あり）
  - Supabase との統合に工夫が必要
- **適用場面**: 素早くプロトタイプを作りたい場合
- **実装難易度**: 低
- **課題解決への適合度**: 中

**推奨**: Supabase Auth（バックエンドと統合されており、利用制限の実装が容易）

---

## 実装時の制約・注意点

### 技術的制約

- **Stripe API レート制限**: 25 req/sec、サブスクリプション API は 10 invoices/min
  - 対策: ローカル DB にデータを保存し、Webhook で同期
- **Supabase の RLS**: 適切に設定しないとデータ漏洩のリスク
  - 対策: テーブルごとに RLS ポリシーを設定し、テストを実施
- **Next.js の認証パターン**: Server Components と Client Components で認証チェックの方法が異なる
  - 対策: サーバー側では `getUser()` を使用、クライアント側では `useUser()` フックを使用

### 注意点

- **セキュリティ**:
  - HTTPS 必須
  - 環境変数で API キーを管理
  - Cookie に `Secure`, `HttpOnly`, `SameSite` 属性を設定
- **UX**:
  - ランディングページからサインアップまでの導線を明確に
  - 利用制限に達した際のメッセージを分かりやすく表示
- **データ移行**:
  - 現在の IndexedDB データを Supabase に移行する必要がある
  - 移行スクリプトを作成し、ユーザーごとにデータをインポート

---

## 判断材料の統合

### 技術選択の判断チェックリスト

- [x] Supabase Auth の動作原理を理解できたか
- [x] Stripe サブスクリプションと使用量制限の対応関係が明確か
- [x] ランディングページと認証フローの構成を理解できたか
- [x] 利用制限（一日一回）の実装方法が明確か
- [x] 技術選択の判断に必要な概念的理解が得られたか

### 課題解決の確信度評価

- **技術特性ベースの評価**: Supabase + Stripe の組み合わせは、認証・DB・課金を統合的に管理でき、課題要件に適合している
- **解決可能性**: 高（既存の実装事例が多数あり、公式ドキュメントも充実）
- **不確実性**: データ移行の複雑さ、RLS の設定ミスによるセキュリティリスク

---

## 次のアクション提案

この調査結果を踏まえて、以下のステップを提案します：

1. **実装計画書の作成**: Phase 4 の詳細な実装計画を作成し、ユーザーに確認
2. **UI 改善の実装**: トレーニング開始ボタンの配置調整（短期タスク）
3. **Supabase プロジェクトのセットアップ**: 認証とデータベースの基盤構築
4. **ランディングページの実装**: サービス紹介とサインアップ導線
5. **Stripe 連携の実装**: サブスクリプション管理と Webhook ハンドリング

---

## 不明点・確認が必要な事項

- **ランディングページのデザイン**: ユーザーの希望するデザインやコンテンツを確認
- **課金プラン**: Free と Pro 以外のプランが必要か
- **データ移行**: 既存ユーザーのデータをどのように移行するか（現時点ではローカルのみなので不要の可能性）
- **デプロイ先**: Vercel を想定しているが、他のプラットフォームを希望するか
