# 詳細ソリューション設計：good_question (真因特定トレーニングゲーム)

## 1. 詳細技術アーキテクチャ設計

### システムアーキテクチャ概要
本システムは、ユーザーの「質問力」を鍛えるための実戦型トレーニングアプリです。低遅延な反応と複雑なロールプレイを実現するため、最新のLLM（Gemini 2.0 Flash）とクライアントサイドでの永続化を組み合わせたアーキテクチャを採用しています。

#### コンポーネント構成
```mermaid
graph TB
    subgraph Frontend [Next.js App (Client Side)]
        UI[React Components / Framer Motion]
        Store[Dexie.js / IndexedDB]
        GameLogic[Game State Management]
    end

    subgraph Backend [Next.js API Routes]
        ChatAPI[app/api/chat/route.ts]
    end

    subgraph AI_Service [Google AI Studio]
        Gemini[Gemini 2.0 Flash Exp]
    end

    UI --> GameLogic
    GameLogic --> ChatAPI
    GameLogic --> Store
    ChatAPI --> Gemini
    Gemini --> ChatAPI
    Store --> UI
```

### データベース詳細設計 (Dexie.js / IndexedDB)
サーバーレスかつ低コストでユーザーデータを永続化するため、クライアントサイドDBを採用しています。

#### スキーマ定義 (Dexie.js)
```typescript
// gameSessions: セッションの基本情報とステータス
{
  id: "++",                 // 自動採番
  industry: "string",       // 業界
  theme: "string",          // テーマ
  difficulty: "string",     // 難易度
  totalScore: "number",    // 総合点
  status: "active | archived", // 50件上限管理用
  helpCount: "number",      // ヘルプ使用回数
  timestamp: "number"       // 並び替え用
}

// chatMessages: 対話ログとヘルプ内容
{
  id: "++",
  sessionId: "string",      // SessionIDへのインデックス
  role: "user | assistant",
  content: "string",
  helpUsed: "boolean",      // ヘルプを使用した発言か
  helpContent: "string",    // AIから提示されたアドバイス全文
  reachability: "number",   // 真因到達度 (%)
  timestamp: "number"
}

// userStats: 累積統計と思考の癖
{
  key: "singleton",
  totalSessions: "number",
  avgScores: "{ structure, empathy, hypothesis }",
  knowledgeNotes: "string[]", // 思考の癖 (Knowledge Note)
  weakPoints: "string[]",     // 重点克服ポイント
  lastUpdated: "number"
}
```

### API設計詳細
### API設計詳細
#### POST `/api/chat`
Geminiとの対話を仲介する主要なエンドポイントです。

- **リクエスト・モード**:
  - `training`: 演技（Facilitator）との対話。直近ログのみ送信。
  - `help`: 状況整理と助言（Helper）。現在のコンテキストを要約。
  - `evaluation`: ロジカル添削（Reviewer）。全ログと過去統計を送信。
  - `setup`: 事前指導（Mentor）。弱点克服型のシナリオガチャを生成。
- **動的シナリオ・ガチャ**:
  - クライアントの性格背景（表の顔）と、隠された真因（裏の顔）をAIがランダムに組み合わる。
- **アウトプット・アダプター**:
  - モデル応答の `真因到達度：(\d+)%` を抽出してUIに反映。
  - ヘルプレスポンスはポップアップ用のMarkdownとしてパース。

## 2. 詳細機能設計

### フロントエンド詳細設計 (Next.js + React 19)
`app/page.tsx` において、複雑なゲーム状態を管理しています。

- **状態遷移 (GameState)**:
  - `welcome`: 初期設定（難易度・業界選択）
  - `training`: 質問フェーズ（最大10回）。`reachability` State を更新。
  - `evaluation`: ユーザーによる真因特定入力。
  - `result`: 最終スコアとスキル分析。

### 永続化レイヤー：Dexie.js (IndexedDB Wrapper)
本システムでは、ユーザーの学習履歴、各セッションのチャットログ、レベル・XP等の統計情報をブラウザ内で完結して保存するために `Dexie.js` を採用しています。

#### 技術的な詳細と選定理由
1. **IndexedDB の抽象化**: 
   - `IndexedDB` はブラウザが持つ唯一の本格的なトランザクション型データベースですが、そのAPIは極めて難解です。`Dexie.js` はこれを **Promise ベース** で直感的に操作可能にします。
2. **パフォーマンス**: 
   - 膨大なチャット履歴を保存しても、B-treeインデックスにより高速な検索が可能です。数万件の過去ログから「以前の良い質問」を抽出して表示するような機能が、遅延なしで実現できます。
3. **データの一貫性**: 
   - **トランザクション機能** を備えており、統計データの更新とチャットメッセージの保存が同時に行われる際、一方が失敗してもデータの整合性を保つことができます。
4. **React との親和性**: 
   - `useLiveQuery` フック（将来導入予定）などを用いることで、データベースの更新を UI にリアクティブに反映させることが容易です。

### プロンプト設計の責任分解 (Multi-Role Logic)
AIの「演技」と「指導」の矛盾を防ぎ、専門性を高めるために以下の4つの役割に分離します。

| 役割名 | 所在ファイル | モード | 責務 |
| :--- | :--- | :--- | :--- |
| **Facilitator** | `systemprompt.md` | `training` | クライアントを演じ、情報の段階的開示を行う。 |
| **Mentor** | `setup_prompt.md` | `setup` | 過去の弱点分析と、ガチャシナリオの動的生成。 |
| **Helper** | `help_prompt.md` | `help` | 煮詰まった際の状況整理と、具体的アクションの示唆。 |
| **Reviewer** | `evalprompt.md` | `evaluation` | 3軸評価、ピンポイントな言い換え案の提示。 |

**判断の根拠**: 
- ゲーム進行中のAIに「詳細なスキル評価」のルールを過剰に学習させると、演技が疎かになる「Instruction Drift」が発生しやすいため。
- 評価ロジックを切り出すことで、ゲーム内容には手を加えずに評価基準だけをアップデート（例：コンサル向けから営業向けへ変更）することが容易になります。

## 3. インフラ・デプロイ詳細設計

### デプロイ構成
- **Hosting**: Vercel (Next.js に最適化)
- **Environment Variables**:
  - `GOOGLE_GENERATIVE_AI_API_KEY`: Google AI Studio から発行された API キー

### 運用・セキュリティ
- **APIキー保護**: フロントエンドから直接 Gemini API を呼ばず、Next.js の API Route を経由させることで API キーを秘匿。
- **認証**: 現状はローカルストレージ（Dexie）管理のため、認証なしで利用可能（将来的に Clerk 等の導入余地あり）。

## 4. 今回の技術的判断の振り返り (逆引きポイント)

1. **なぜ Gemini 2.0 Flash か？**
   - 質問トレーニングでは対話のテンポが重要。最速クラスのモデルを選ぶことで、ユーザーの思考を妨げない。
2. **なぜ Dexie.js (Stored in Browser) か？**
   - 個人のトレーニング記録において、サーバーサイドのDB構築コストと個人情報保護のオーバーヘッドを削減。
3. **なぜ System Prompt を外部ファイル (`systemprompt.md`) にしたか？**
   - ゲームロジックが極めて複雑なため、コード内ハードコードを避け、AIエンジニア（またはAI自身）がロジックをリファクタリングしやすくした。
4. **なぜ CSS Framework に Tailwind 4 を選んだか？**
   - 最新の CSS 機能（Container Queries 等）への対応と、ビルド速度の向上。

---
本設計は、@[rules/cursor_project_rules/01_app_coding_rules/03_solution_design_evaluation/01-detailed-solution-design.md] のガイドラインに基づき作成されました。
